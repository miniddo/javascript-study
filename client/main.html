<head>
  <title>javascript-study</title>
</head>

<body>

<div>
1. Arrow Function(화살표 함수)
: (한번에 여러 작업을 처리) 작업을 할 때 필요한 runnable 객체(실행코드)를 편리하게 사용 => 익명함수를 편하게 사용
 
* 일반 함수 vs 화살표 함수
1-1. 일반 함수
- this의 탐색 범위가 함수의 { } 안에서 찾음: 함수 내부의 this를 오버라이딩
- ex) this는 template 변수를 가리킴
- 생성자 내에서 생성자 함수 new를 호출하면 내부에서 this는 인스턴스 그 자체를 가리킴
- bind, apply, call, new
1-2. 화살표 함수
- this 바인딩을 갖지 않음: 일반적인 인자/변수와 동일하게 취급
- arrow function을 사용하여 변수 scope 유지, 변수들이 사용되는 위치와 상관없이 정의된 scope가 binding 됨
- 해당 function을 정의한 영역의 this를 가져옴: 한 단계 더 위의 element를 가리킴
- ex) this는 window 객체를 가리킴

 
 * ES6 문법
 function objFunction() {
     console.log('Inside `objFunction`:', this.foo); // 13
     return {
         foo: 25,
         bar: () => console.log('Inside `bar`:', this.foo), // 13
     };
 }
 objFunction.call({ foo: 13 }).bar();
 
 * ES5 문법
 function objFunction() {
     var _this = this; // ES6에서처럼 this를 변수처럼 사용하려면 새로운 변수를 만들어야 함
 
     console.log('Inside `objFunction`:', this.foo);
     return {
         foo: 25,
         bar: function bar() {
             return console.log('Inside `bar`:', _this.foo);
         }
     };
 }
 objFunction.call({ foo: 13 }).bar();

 
 * 매개변수 지정 방법
 () => {...} // 매개변수가 없을 경우
 x => {...} // 매개변수가 한 개인 경우, 소괄호 생략
 (x, y) => {...} // 매개변수가 여러 개인 경우
 
 * 함수 몸체 지정 방법
 x => { return x * x } // single line block
 x => x * x // 함수 몸체가 한줄 구문의 경우, 중괄호를 생략할 수 있으며 암묵적으로 return 됨
 
 () => { return {a : 1}; }
 () => ({a : 1}) // 객체 반환시에도 동일, 단 소괄호를 사용한다
 
 () => { // multi line block
     const x = 10;
     return x * x;
 }
 </div>

<br>

 <div>
 2. for-in vs for-of
 - for-in: 객체의 '속성'을 순회하기 위한 구문
 - for-of: 객체의 '요소'를 순회학 위한 구문
 
 const array1 = [1, 2, 3, 4, 5];
 for(let i in array1) {
     console.log(i); // 0 1 2 3 4 (인덱스)
 }
 for(let j of array1) {
     console.log(j); // 1 2 3 4 5 (각 요소)
 }
 
 const array2 = {
     color: 'red',
     weight: 40,
     height: 160,
     [Symbol.iterator]: function* () { // 객체의 경우, 반복가능하도록 만들어야 함
         yield this.color;
         yield this.weight;
         yield this.height;
     }
 }
 for(let i in array2) {
     console.log(i); // color weight height
 }
 for(let j of array2) {
     console.log(j); // red 40 160
 } 
</div>

<br>

<div>
3. let vs const
- const: 상수, 변하지 않는 값 => 선언과 동시에 할당 이루어짐
- let: 재할당 가능 / const: 재할당 불가능

const user = {name: 'hyemin'}; // 객체 선언시, const 사용
user.name = 'jimin'
console.log(user) // {name: 'jimin'} - 객체의 내용은 변경 가능
</div>

<br>

<div>
4. 매개변수 기본값 (Default Parameter value)
- 함수를 호출할 때 매개변수의 개수만큼 인수를 전달하지 않으면, undefined가 나옴
- 따라서 매개변수에 적절한 인수가 전달되었는지 함수 내부에서 확인

function sum(x=0, y=0) {
  return x + y;
}
console.log(sum(1)); // 1
console.log(sum(1, 2)) // 3


function foo(x, y = 0) {
  console.log(arguments);
}
console.log(foo.length); // 1
sum(1); // arguments {'0': 1}
sum(1,2); // arguments {'0': 1, '1': 2}
</div>

<br>

<div>
5. rest 파라미터
- 매개변수 이름 앞에 세개의 점 ...을 붙여서 정의한 매개변수
- rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받음

function bar(param1, param2, ...rest) {
  console.log(param1); // 1
  console.log(param2); // 2
  console.log(rest); // [3, 4, 5]
}
bar(1, 2, 3, 4, 5);
</div>

<br>

<div>
6. prototype(프로토타입)
- java, c++: class 기반 객체지향 프로그래밍 언어 => 객체 생성 이전에 class를 정의하고 이를 통해 객체(인스턴스)를 생성
- javascript: prototype 기반 객체지향 프로그래밍 언어 => class 없이 객체 생성
: javascript의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있음, 이러한 부모 객체를 prototype(프로토타입) 객체 또는 prototype(프로토타입)
: 부모 객체의 함수들을 특별한 정의 없이 바로 사용할 수 있음


* [[prototype]] vs prototype 프로퍼티
- [[prototype]]: 객체의 입장에서 자신의 부모 역할을 하는 프로토타입객체를 가리키며, 함수 객체의 경우 Function.prototype
- prototype 프로퍼티: 함수 객체가 생성자로 나올 때 이 함수를 통해 생성될 객체의 부모역할을 하는 개체를 가리킴

function Person(name) {
    this.name = name;
}
var foo = new Person('park');
console.log(Person.__proto__ === Function.prototype);
console.log(foo.__proto__ === Person.prototype); 
---------------------------------------------------------------------------
var student = {
    name: 'hyemin',
    age: 25
}
console.log(student.__proto__ === Object.prototype);
console.log(Object.prototype.constructor === Object);
console.log(Object.__proto__ === function.prototype);
---------------------------------------------------------------------------
function Person(name, gender) {
    this.name = name;
    this.gender = gender;
    this.sayHello = function() {
        console.log('hi, my name is' + this.name);
    };
}
var foo = new Person('hm', 'female');

console.log(foo.__proto__ === Person.prototype);
console.log(Person.prototype.__proto__ == Object.prototype);
console.log(Person.prototype.constructor === Person);
console.log(Person.__proto__ == function.prototype);


* constructor 프로퍼티
- 객체의 입장에서 자신을 생성한 객체를 가리킴

function Person(name) {
    this.name = name;
}
var foo = new Person('Lee'); // foo는 Person() 생성자 함수에 의해 생성된 객체
console.log(Person.prototype.constructor === Person); // Person() 생성자 함수에 의해 생성된 객체를 생성한 객체는 Person() 생성자 함수
console.log(foo.constructor === Person); // foo 객체를 생성한 객체는 Person() 생성자 함수
console.log(Person.constructor === Function); // Person() 생성자 함수를 생성한 객체는 Function() 생성자 함수


6-1. Array.prototype.map()
- map() method는 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열 반환

const array1 = [ 1, 4, 9, 16 ];
const map1 = array1.map( x => x * 2 );
console.log(map1); // [ 2, 8, 18, 32 ]

6-2. Array.prototype.pop()
- pop() method는 배열에서 마지막 요소를 제거하고 그 요소를 반환

const array1 = [ 'a', 'b', 'c', 'd' ];
console.log(array1.pop()); // 'd'
console.log(array1); // [ 'a', 'b', 'c' ]

6-3. Array.prototype.slice()
- slice() method는 어떤 배열의 begin부터 end에 대한 새로운 배열을 객체로 반환

const array1 = [ 'a', 'b', 'c', 'd', 'e' ];
console.log(array1.slice(2)); //[ 'c', 'd', 'e' ]
console.log(array1.slice(2, 4)); // [ 'c', 'd' ] 

6-4. Array.prototype.some()
- some() method는 배열 안의 어떤 요소라도 주어진 판별 함수를 통과하는지 테스트

const array1 = [1, 2, 3, 4, 5];

const even = (element) => element % 2 === 0;
console.log(array1.some(even)); // true

6-5. Array.prototype.splice()
- splice() method는 배열의 기존 요소를 삭제 또는 교체하거나 새 요소를 추가하여 배열의 내용을 변경

const array1 = ['a', 'b', 'c', 'd', 'e'];

console.log(array1.splice(2, 0, 'x')); // ['a', 'b', 'x', 'c', 'd', 'e']
console.log(array1.splice(2, 0, 'x', 'y')); // ['a', 'b', 'x', 'y', 'c', 'd', 'e']
console.log(array1.splice(3, 1)); // ['a', 'b', 'c', 'e']
console.log(array1.splice(2, 1, 'x')); // ['a', 'b', 'x', 'd', 'e']
console.log(array1.splice(-2, 1)); // ['a', 'b', 'c', 'e']
console.log(array1.splice(2)) // ['a', 'b']

</div>

 
</body>